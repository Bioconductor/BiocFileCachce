#' @import methods
#' @import httr
#' @import rappdirs
#' @importFrom utils tar zip untar unzip
#' @importFrom dplyr mutate
.BiocFileCacheBase = setClass(
    "BiocFileCacheBase",
    slots=c(cache="character")
)

.BiocFileCacheReadOnly = setClass(
    "BiocFileCacheReadOnly",
    contains="BiocFileCacheBase",
    slots=c(rid="character")
)

.BiocFileCache = setClass(
    "BiocFileCache",
    contains="BiocFileCacheBase"
)

#' BiocFileCache class
#'
#' This class represents the location of files stored on disk. Use the
#' return value to add and retrieve files that persist across
#' sessions.
#'
#' @details The package defines 'BiocFileCache', 'BiocFileCacheBase' and
#' 'BiocFileCacheReadOnly' classes.
#'
#' Slots unique to 'BiocFileCache' and  related classes:
#' \itemize{
#'   \item{'cache': }{character(1), Describes the On-disk location
#'     (directory path) of the cache}
#'   \item{'rid': }{character(), List of the unique rids in the cache. }
#' }
#'
#' The cache creates an RSQLite database to keep track of local and remote
#' resources. Each item located in the database will have the following
#' information:
#' \itemize{
#'   \item{'rid': }{resource id. Autogenerated. This is a unique identifier
#'     automatically generated when a resource is added to the cache}
#'   \item{'rname': }{resource name. This is given by the user when a
#'     resource is added to the cache. It does not have to be unique
#'     and can be updated at anytime. We recommend descriptive key
#'     words and identifers.}
#'   \item{'create_time': }{The date and time a resource is added to the cache.}
#'   \item{'access_time': }{The date and time a resource is utilized
#'     within the cache. The access time is updated when the resource
#'     is updated or accessed}
#'   \item{'rpath': }{resource path. This is the path to the local
#'     (on-disk) file}
#'   \item{'rtype': }{resource type. Either "relative", "local", or
#'     "web", indicating if the resource has a remote origin}
#'   \item{'fpath': }{If rtype is "web", this is the link to the
#'     remote resource. It will be utilized to download or update the
#'     remote data}
#'   \item{'last_modified_time': }{For a remote resource, the
#'     last_modified (if available) information for the local copy of
#'     the data. This information is checked against the remote
#'     resource to determine if the local copy is stale and needs to
#'     be updated}
#' }
#'
#' All functions have a quick implementation where if the BiocFileCache object
#' is not passed as an argument, the function uses default 'BiocFileCache()' for
#' implementation. e.g 'bfcinfo()' can be used instead of
#' 'bfcinfo(BiocFileCache())'. The only function this is not available for is
#' 'bfcmeta()<-'; The BiocFileCache object must be defined as a varaible and
#'  passed as an argument. See vignette("BiocFileCache") for more details.
#'
#' @param cache character(1) On-disk location (directory path) of
#'     cache. For default location see \code{\link[rappdirs]{user_cache_dir}}.
#' @return For 'BiocFileCache': a \code{BiocFileCache} instance.
#' @examples
#' # bfc <- BiocFileCache()            # global cache
#' # bfc
#' bfc0 <- BiocFileCache(tempfile())         # temporary catch for examples
#' @name BiocFileCache-class
#' @aliases BiocFileCache
#' @export BiocFileCache
BiocFileCache <-
    function(cache=user_cache_dir(appname="BiocFileCache"))
{

    stopifnot(is.character(cache), length(cache) == 1L, !is.na(cache))

    if (!file.exists(cache)){
        if(!.biocfilecache_flags$get_create_asked() || !missing(cache)){
            ans <- .util_ask(cache,
                             "\n  does not exist, create directory?")
            if (missing(cache)) .biocfilecache_flags$set_create_asked()
        } else {
            ans <- FALSE
        }
        if (ans){
            dir.create(cache, recursive=TRUE)
        } else {
            cache <- file.path(tempdir(), "BiocFileCache")
            message("Using temporary cache ", cache)
            if (!file.exists(cache))
                dir.create(cache, recursive=TRUE)
        }
    }
    bfc <- .BiocFileCache(cache=cache)
    .sql_create_db(bfc)
    bfc
}

#' @export
setGeneric("bfccache",
    function(x) standardGeneric("bfccache")
)

#' @describeIn BiocFileCache Get the location of the on-disk cache.
#' @param x A \code{BiocFileCache} instance or, if missing, the result
#'     of \code{BiocFileCache()}.
#' @return For 'bfccache': character(1) location of the directory
#'     containing the cache.
#' @examples
#' bfccache(bfc0)
#' @aliases bfccache
#' @exportMethod bfccache
setMethod("bfccache", "BiocFileCacheBase", function(x) x@cache)

#' @rdname BiocFileCache-class
#' @aliases bfccache,missing-method
#' @exportMethod bfccache
setMethod("bfccache", "missing", function(x) bfccache(BiocFileCache()))

#' @describeIn BiocFileCache Get the number of objects in the file
#'     cache.
#' @return For 'length': integer(1) Number of objects in the file
#'     cache.
#' @examples
#' length(bfc0)
#' @importFrom stats setNames
#' @exportMethod length
setMethod("length", "BiocFileCacheBase", function(x) length(bfcrid(x)))

#' @rdname BiocFileCache-class
#' @aliases bfcrid
#' @export
setGeneric("bfcrid", function(x) standardGeneric("bfcrid"))

#' @rdname BiocFileCache-class
#' @aliases bfcrid,missing-method
#' @exportMethod bfcrid
setMethod("bfcrid", "missing", function(x) bfcrid(BiocFileCache()))

#' @describeIn BiocFileCache Get the rids of the object.
#' @aliases bfcrid,BiocFileCacheReadOnly-method
#' @exportMethod bfcrid
setMethod("bfcrid", "BiocFileCacheReadOnly", function(x) x@rid)

#' @rdname BiocFileCache-class
#' @aliases bfcrid,BiocFileCache-method
#' @exportMethod bfcrid
setMethod("bfcrid", "BiocFileCache", function(x) .get_all_rids(x))

#' @describeIn BiocFileCache Subset a BiocFileCache object.
#' @param drop Ignored.
#' @return For '[': A subset of the BiocFileCache object.
#' @exportMethod [
setMethod("[", c("BiocFileCache", "character", "missing"),
    function(x, i, j, ..., drop=TRUE)
{
    stopifnot(all(i %in% bfcrid(x)))
    stopifnot(identical(drop, TRUE))

    .BiocFileCacheReadOnly(x, rid=as.character(i))
})

#' @rdname BiocFileCache-class
#' @aliases [,BiocFileCacheReadOnly,character,missing-method
#' @exportMethod [
setMethod("[", c("BiocFileCacheReadOnly", "character", "missing"),
    function(x, i, j, ..., drop=TRUE)
{
    stopifnot(all(i %in% bfcrid(x)))
    stopifnot(identical(drop, TRUE))

    initialize(x, rid=as.character(i))
})

#' @rdname BiocFileCache-class
#' @aliases [,BiocFileCache,missing,missing-method
#' @exportMethod [
setMethod("[", c("BiocFileCache", "missing", "missing"),
    function(x, i, j, ..., drop=TRUE)
{
    stopifnot(identical(drop, TRUE))

    .BiocFileCacheReadOnly(x, rid=bfcrid(x))
})

#' @rdname BiocFileCache-class
#' @aliases [,BiocFileCacheReadOnly,missing,missing-method
#' @exportMethod [
setMethod("[", c("BiocFileCacheReadOnly", "missing", "missing"),
    function(x, i, j, ..., drop=TRUE)
{
    x                                   # no-op
})

#' @describeIn BiocFileCache Get a file path for select resources from
#'     the cache.
#' @param i character() 'rid' identifiers.
#' @param j Ignored.
#' @return For '[[': named character(1) rpath for the given resource
#'     in the cache.
#' @exportMethod [[
setMethod("[[", c("BiocFileCacheBase", "character", "missing"),
    function(x, i, j)
{
    stopifnot(length(i) == 1L, i %in% bfcrid(x))

    .sql_update_time(x, i)
    .sql_get_rpath(x, i)
})

#' @describeIn BiocFileCache Set the file path of selected resources
#'     from the cache.
#' @param value character(1) Replacement file path.
#' @return For '[[<-': Updated BiocFileCache, invisibly.
#' @exportMethod [[<-
setReplaceMethod("[[", c("BiocFileCache", "character", "missing", "character"),
    function(x, i, j, ..., value)
{
    stopifnot(length(i) == 1L, length(value) == 1L)
    stopifnot(file.exists(value))

    .sql_update_time(x, i)
    .sql_set_rpath(x, i, value)
    rtype <- .sql_get_rtype(x, i)
    if (identical(rtype, "relative") || identical(rtype, "web")) {
        warning("updating rpath, changing rtype to 'local'")
        .sql_set_rtype(x, i, "local")
    }
    x
})

#' @export
setGeneric("bfcnew",
    function(x, rname, rtype=c("relative", "local"), ext=NA_character_)
    standardGeneric("bfcnew"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcnew,missing-method
#' @exportMethod bfcnew
setMethod("bfcnew", "missing",
    function(x, rname, rtype=c("relative", "local"), ext=NA_character_)
{
    bfcnew(x=BiocFileCache(), rname=rname, rtype=rtype, ext=ext)
})

#' @describeIn BiocFileCache Add a resource to the database
#' @param rname character(1) Name of object in file cache. For
#'     'bfcupdate' a character vector of replacement rnames.
#' @param ext character(1) A file extension to add to the local
#'     copy of the file (e.g., \sQuote{sqlite}, \sQuote{txt},
#'     \sQuote{tar.gz}).
#' @return For 'bfcnew': named character(1), the path to save your
#'     object / file.  The name of the return value is the unique rid
#'     for the resource.
#' @examples
#' path <- bfcnew(bfc0, "NewResource")
#' path
#' @aliases bfcnew
#' @exportMethod bfcnew
setMethod("bfcnew", "BiocFileCache",
    function(x, rname, rtype=c("relative", "local"), ext=NA_character_)
{
    stopifnot(length(rname) == 1L, is.character(rname), !is.na(rname))
    stopifnot(length(ext) == 1L, is.character(ext))
    rtype <- match.arg(rtype)

    rid <- .sql_new_resource(x, rname, rtype, NA_character_, ext)
    .sql_set_last_modified(x, rid, NA_character_)
    .sql_set_etag(x, rid, NA_character_)
    rpath <- .sql_get_rpath(x, rid)
    setNames(rpath, rid)
})

#' @export
setGeneric("bfcadd",
    function(
        x, rname, fpath = rname, rtype=c("auto", "relative", "local", "web"),
        action=c("copy", "move", "asis"), proxy="",
        download=TRUE, config=list(), ...
    ) standardGeneric("bfcadd"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcadd,missing-method
#' @exportMethod bfcadd
setMethod("bfcadd", "missing",
    function(
        x, rname, fpath = rname, rtype=c("auto", "relative", "local", "web"),
        action=c("copy", "move", "asis"), proxy="",
        download=TRUE, config=list(), ...
    )
{
    bfcadd(x=BiocFileCache(), rname=rname, fpath=fpath, rtype=rtype,
           action=action, proxy=proxy, download=download, config=config, ...)
})

#' @describeIn BiocFileCache Add an existing resource to the database
#' @param fpath For bfcadd(), character(1) path to current file
#'     location or remote web resource. If none is given, the rname is
#'     assumed to also be the path location. For bfcupdate()
#'     character() vector of replacement web resources.
#' @param rtype character(1) 'local', 'relative', or 'web' indicating
#'     if the resource is a local file, a relative path in the cache,
#'     or a web resource. For \code{bfcnew}: local or relative are
#'     only options. For \code{bfcadd}, the default 'auto' creates
#'     relative or web paths, based on the path prefix.
#' @param action character(1) How to handle the file: create a
#'     \code{copy} of \code{fpath} in the cache directory; \code{move}
#'     the file to the cache directory; or \code{asis} leave the file
#'     in current location but save the path in the cache. If 'rtype
#'     == "relative"', action can not be "asis".
#' @param proxy character(1) (Optional) proxy server.
#' @param download logical(1) If \code{rtype=web}, should remote
#'     resource be downloaded locally immediately.
#' @param config list() passed as config argument in \code{httr::GET}
#' @param ... For 'bfcadd': For \code{action="copy"}, additional
#'     arguments passed to \code{file.copy}. For 'bfcrpaths':
#'     Additional arguments passed to 'bfcadd'. For 'bfcquery': Additional
#'     arguments passed to \code{grepl}. For 'exportbfc': Additional arguments
#'     to the selected outputMethod function. See \code{utils::tar} or
#'     \code{utils::zip} for more information. For 'importbfc': Additional
#'     arguments to the selected archiveMethod function. See \code{utils::untar}
#'     or \code{utils::unzip} for more information. For 'makeBiocFileCacheFromDataFrame':
#'     Additional arguments passed to \code{file.copy}.
#' @return For 'bfcadd': named character(1), the path to save your
#'     object / file.  The name of the character is the unique rid for
#'     the resource.
#' @examples
#' fl1 <- tempfile(); file.create(fl1)
#' bfcadd(bfc0, "Test1", fl1)                 # copy
#' fl2 <- tempfile(); file.create(fl2)
#' bfcadd(bfc0, "Test2", fl2, action="move")         # move
#' fl3 <- tempfile(); file.create(fl3)
#' add3 <- bfcadd(bfc0, "Test3", fl3, rtype="local", action="asis")  # reference
#' rid3 <- names(add3)
#'
#' bfc0
#' file.exists(fl1)                                # TRUE
#' file.exists(fl2)                                # FALSE
#' file.exists(fl3)                                # TRUE
#'
#' # add a remote resource
#' url <- "http://httpbin.org/get"
#' bfcadd(bfc0, "TestWeb", fpath=url)
#' @aliases bfcadd
#' @exportMethod bfcadd
setMethod("bfcadd", "BiocFileCache",
    function(
        x, rname, fpath = rname, rtype = c("auto", "relative", "local", "web"),
        action=c("copy", "move", "asis"), proxy="",
        download=TRUE, config=list(), ...)
{
    stopifnot(is.character(rname), length(rname) == 1L, !is.na(rname))
    stopifnot(is.character(fpath), length(fpath) == 1L, !is.na(fpath))
    action <- match.arg(action)
    rtype <- match.arg(rtype)
    rtype <- .util_standardize_rtype(rtype, fpath, action)
    stopifnot(rtype == "web" || file.exists(fpath))
    stopifnot(is.character(proxy), length(proxy) == 1L, !is.na(proxy))

    rid <- .sql_new_resource(x, rname, rtype, fpath)
    .sql_set_last_modified(x, rid, NA_character_)
    .sql_set_etag(x, rid, NA_character_)
    rpath <- bfcrpath(x, rids = rid)
    if (rtype %in% c("local", "relative")) {
        switch(
            action,
            copy = file.copy(fpath, rpath, ...),
            move = file.rename(fpath, rpath),
            asis = {
                .sql_set_rpath(x, rid, fpath)
                rpath <- bfcrpath(x, rids = rid)
            }
        )
    } else {                            # rtype == "web"
        if (download)
            .util_download(x, rid, proxy, config, "bfcadd()")
    }

    setNames(rpath, rid)
})

#' @export
setGeneric("bfcinfo",
    function(x, rids) standardGeneric("bfcinfo"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcinfo,missing-method
#' @exportMethod bfcinfo
setMethod("bfcinfo", "missing",
    function(x, rids)
{
    bfcinfo(x=BiocFileCache(), rids=rids)
})

#' @describeIn BiocFileCache list resources in database
#' @param rids character() Vector of rids.
#' @return For 'bfcinfo': A \code{bfc_tbl} of current resources in the
#'     database.
#' @examples
#' bfcinfo(bfc0)
#' @aliases bfcinfo
#' @exportMethod bfcinfo
setMethod("bfcinfo", "BiocFileCacheBase",
    function(x, rids)
{
    if (missing(rids))
        rids <- bfcrid(x)
    stopifnot(all(rids %in% bfcrid(x)))

    tbl <- .sql_get_resource_table(x, rids)
    tbl <- mutate(tbl, rpath = unname(bfcrpath(x, rids=rids)))
    class(tbl) <- c("tbl_bfc", class(tbl))
    tbl
})

setOldClass("tbl_bfc")

#' @describeIn BiocFileCache Get the rids of the object
#' @exportMethod bfcrid
setMethod("bfcrid", "tbl_bfc", function(x) .get_tbl_rid(x))

#' @export
setGeneric("bfcpath",
    function(x, rid) standardGeneric("bfcpath"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcpath,missing-method
#' @exportMethod bfcpath
setMethod("bfcpath", "missing",
    function(x, rid)
{
    bfcpath(x=BiocFileCache(), rid=rid)
})

#' @describeIn BiocFileCache display paths of resource
#' @param rid character(1) Unique resource id.
#' @return For 'bfcpath': the file path location to load and original
#'     source information for web resources.
#' @examples
#' bfcpath(bfc0, rid3)
#' @aliases bfcpath
#' @exportMethod bfcpath
setMethod("bfcpath", "BiocFileCacheBase",
    function(x, rid)
{
    stopifnot(!missing(rid), length(rid) == 1L, rid %in% bfcrid(x))

    .sql_update_time(x, rid)
    path <- .sql_get_rpath(x, rid)
    if (.sql_get_rtype(x, rid) == "web") {
        fpath <- .sql_get_fpath(x, rid)
        setNames(c(path, fpath), c(rid, "fpath"))
    } else {
        setNames(path, rid)
    }
})

#' @export
setGeneric("bfcrpath",
    function(x, rnames, ..., rids) standardGeneric("bfcrpath"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcrpath,missing-method
#' @exportMethod bfcrpath
setMethod("bfcrpath", "missing",
    function(x, rnames, ..., rids)
{
    bfcrpath(x=BiocFileCache(), rnames=rnames, ..., rids=rids)
})

#' @describeIn BiocFileCache display rpath of resource. If 'rnames' is
#'     in the cache the path is returned, if it is not it will try to
#'     add it to the cache with 'bfcadd'
#' @param rnames character() list of rnames to search and match on.
#' @return For 'bfcrpath': The local file path location to load.
#' @examples
#' bfcrpath(bfc0, rids = rid3)
#' @aliases bfcrpath
#' @exportMethod bfcrpath
setMethod("bfcrpath", "BiocFileCacheBase",
    function(x, rnames, ..., rids)
{
    if (!missing(rnames) && !missing(rids))
        stop("specify either 'rnames' or 'rids' not both.")

    update_time_and_path <- function(x, i) {
        .sql_update_time(x, i)
        .sql_get_rpath(x, i)
    }

    add_or_return_rname <- function(x, name, ...){
        res <- bfcrid(bfcquery(x, name))
        if (length(res) == 0L){
            tryCatch({
                bfcadd(x, name, ...)
            }, error=function(e) {
                warning(conditionMessage(e))
                NA_character_
            })
        } else if (length(res) == 1L){
            path <- update_time_and_path(x, res)
            setNames(path, res)
        } else {
            warning("rname: '", name ,"' is not unique.")
            NA_character_
        }
    }

    if (missing(rids))
        rids <- bfcrid(x)

    if (!missing(rnames)) {
        rpaths <- vapply(rnames, add_or_return_rname, character(1), x=x, ...)
        if (anyNA(rpaths)) {
            rmdx <- setdiff(bfcrid(x), rids)
            if (length(rmdx) > 0L)
                bfcremove(x, rmdx)
            stop("all 'rnames' not found or valid.")
        }
        setNames(rpaths, .fix_rnames(x, names(rpaths)))
    } else {
        stopifnot(all(rids %in% bfcrid(x)))
        rpaths <- vapply(rids, update_time_and_path, character(1), x = x)
        setNames(rpaths, rids)
    }

})

#' @export
setGeneric("bfcupdate",
    function(x, rids, value, ...) standardGeneric("bfcupdate"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcupdate,missing-method
#' @exportMethod bfcupdate
setMethod("bfcupdate", "missing",
    function(x, rids, value, ...)
{
    bfcupdate(x=BiocFileCache(), rids=rids, value=value, ...)
})

#' @describeIn BiocFileCache Update a resource in the cache
#' @param rpath character() vector of replacement rpaths.
#' @return For 'bfcupdate': an updated \code{BiocFileCache} object,
#'     invisibly.
#' @examples
#' bfcupdate(bfc0, rid3, rpath=fl3, rname="NewRname")
#' bfc0[[rid3]] = fl1
#' bfcupdate(bfc0, "BFC5", fpath="http://google.com")
#' @aliases bfcupdate
#' @exportMethod bfcupdate
setMethod("bfcupdate", "BiocFileCache",
    function(x, rids, rname=NULL, rpath=NULL, fpath=NULL,
             proxy="", config=list(), ask=TRUE)
{
    stopifnot(!missing(rids), all(rids %in% bfcrid(x)))
    stopifnot(
        is.null(rname) || (length(rids) == length(rname)),
        is.null(rpath) || (length(rids) == length(rpath)),
        is.null(fpath) || (length(rids) == length(fpath))
    )
    stopifnot(
        is.null(rname) || is.character(rname),
        is.null(rpath) || is.character(rpath),
        is.null(fpath) || is.character(fpath)
    )

    for (i in seq_along(rids)) {

        .sql_update_time(x, rids[i])

        if (!is.null(rname)) {
            .sql_set_rname(x, rids[i], rname[i])
        }

        if (!is.null(rpath)) {
            if (!file.exists(rpath[i]))
                stop(
                    "bfcupdate() failed",
                    "\n  rid: ", rids[i],
                    "\n  rpath: ", sQuote(rpath[i]),
                    "\n  reason: rpath does not exist.",
                    call.=FALSE
                )
            .sql_set_rpath(x, rids[i], rpath[i])
            rtype <- .sql_get_rtype(x, rids[i])
            if (identical(rtype, "relative") || identical(rtype, "web")){
                warning("updating rpath, changing rtype to 'local'")
                .sql_set_rtype(x, rids[i], "local")
            }
        }

        if (!is.null(fpath)) {
            if (.sql_get_rtype(x, rids[i]) != "web")
                stop("bfcupdate() failed",
                    "\n  rid: ", rids[i],
                    "\n  reason: resource rtype is not 'web'",
                    call.=FALSE)

            if (ask){
                doit <-
                    .util_ask("Setting a new remote path results in immediate\n",
                              "  download and overwriting of existing file.\n",
                              "  Continue?")
            } else {
                doit <- TRUE
            }
            if (doit) {
                .util_download_and_rename(
                    x, rids[i], proxy, config, "bfcupdate()", fpath[i]
                )
                .sql_set_fpath(x, rids[i], fpath[i])
            }
        }
    }

    invisible(x)
})

#' @rdname BiocFileCache-class
#' @export
setGeneric("bfcmeta<-",
    function(x, name, ..., value)
        standardGeneric("bfcmeta<-"),
    signature = "x"
)

#' @describeIn BiocFileCache add meta data table in database
#' @param name character(1) name of metadata table.
#' @return For 'bfcmeta': updated BiocFileCache, invisibly
#' @examples
#' meta = data.frame(list(rid = paste("BFC",seq_len(bfccount(bfc0)), sep=""),
#'                        num=seq(bfccount(bfc0),1,-1),
#'                        data=c(paste("Letter",
#'                        letters[seq_len(bfccount(bfc0))]))),
#'                   stringsAsFactors=FALSE)
#' bfcmeta(bfc0, name="resourcedata") <- meta
#' @aliases bfcmeta<-
#' @exportMethod bfcmeta<-
setReplaceMethod("bfcmeta", "BiocFileCacheBase",
    function(x, name, ..., value)
{
    stopifnot("rid" %in% colnames(value))
    rids <- value$rid
    stopifnot(all(rids %in% bfcrid(x)))
    stopifnot(is.character(name), length(name) == 1L, !is.na(name))

    if (name %in% .RESERVED$TABLES)
        stop(
            "'", name, "' cannot be added; reserved table names: ",
            paste(sQuote(.RESERVED$TABLES), collapse=", ")
        )

    if (any(colnames(value) %in% .RESERVED$COLUMNS))
        stop(
            "'value' (metadata) cannot contain colnames ",
            paste(sQuote(.RESERVED$COLUMNS), collapse= ", ")
        )

    .sql_meta_gets(x, name, value, ...)
    x
})

#' @export
setGeneric("bfcmetaremove",
    function(x, name, ...) standardGeneric("bfcmetaremove"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcmetaremove,missing-method
#' @exportMethod bfcmetaremove
setMethod("bfcmetaremove", "missing",
    function(x, name, ...)
{
    bfcmetaremove(x=BiocFileCache(), name=name, ...)
})

#' @describeIn BiocFileCache remove meta data table in database
#' @return For 'bfcmetaremove': updated BiocFileCache, invisibly
#' @examples
#' \dontrun{bfcmetaremove(bfc0, "resourcedata")}
#' @aliases bfcmetaremove
#' @exportMethod bfcmetaremove
setMethod("bfcmetaremove", "BiocFileCacheBase",
    function(x, name, ...)
{
    stopifnot(
        !missing(name), is.character(name), length(name) == 1L, !is.na(name)
    )
    if (name %in% .RESERVED$TABLES)
        stop("reserved table '", name, "' cannot be removed")

    .sql_meta_remove(x, name, ...)

    invisible(x)
})

#' @export
setGeneric("bfcmetalist",
    function(x) standardGeneric("bfcmetalist"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcmetalist,missing-method
#' @exportMethod bfcmetalist
setMethod("bfcmetalist", "missing",
    function(x)
{
    bfcmetalist(x=BiocFileCache())
})

#' @describeIn BiocFileCache retrieve list of metadata table
#' @return For 'bfcmetalist': returns a character() of all metadata tables
#'     currently in the database. If no metadata tables are available returns
#'     character(0)
#' @examples
#' bfcmetalist(bfc0)
#' @aliases bfcmetalist
#' @exportMethod bfcmetalist
setMethod("bfcmetalist", "BiocFileCacheBase",
    function(x)
{
    .sql_meta_list(x)
})

#' @export
setGeneric("bfcmeta",
    function(x, name, ...) standardGeneric("bfcmeta"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcmeta,missing-method
#' @exportMethod bfcmeta
setMethod("bfcmeta", "missing",
    function(x, name, ...)
{
    bfcmeta(x=BiocFileCache(), name=name, ...)
})

#' @describeIn BiocFileCache retrieve metadata table
#' @return For 'bfcmeta': returns a data.frame representation of database
#'     table
#' @examples
#' tbl = bfcmeta(bfc0, "resourcedata")
#' tbl
#' @aliases bfcmeta
#' @exportMethod bfcmeta
setMethod("bfcmeta", "BiocFileCacheBase",
    function(x, name, ...)
{
    if (missing(name)) {
        tbls <- paste(sQuote(bfcmetalist(x)), collapse=", ")
        if (!nzchar(tbls))
            tbls <- NA_character_
        stop("metadata table 'name' missing, possible values: ", tbls)
    }
    stopifnot(is.character(name), length(name) == 1L, !is.na(name))

    .sql_meta(x, name, ...)
})

#' @export
setGeneric("bfcquerycols",
    function(x) standardGeneric("bfcquerycols")
)

#' @rdname BiocFileCache-class
#' @aliases bfcquerycols,missing-method
#' @exportMethod bfcquerycols
setMethod("bfcquerycols", "missing",
    function(x)
{
    bfcquerycols(x=BiocFileCache())
})

#' @describeIn BiocFileCache Get all the possible columns to query
#' @return For 'bfcquerycols': character() all columns in all database tables
#'      available for query.
#' @examples
#' bfcquerycols(bfc0)
#' @aliases bfcquerycols
#' @exportMethod bfcquerycols
setMethod("bfcquerycols", "BiocFileCacheBase",
    function(x)
{
    .get_all_colnames(x)
})

#' @export
setGeneric("bfcquery",
    function(x, query, field=c("rname", "rpath", "fpath"), ...)
        standardGeneric("bfcquery"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcquery,missing-method
#' @exportMethod bfcquery
setMethod("bfcquery", "missing",
    function(x, query, field=c("rname", "rpath", "fpath"), ...)
{
    bfcquery(x=BiocFileCache(), query=query, field=field, ...)
})

#' @describeIn BiocFileCache query resource
#' @param query character() Regular expression pattern(s) to match in
#'     resource. It will match the pattern against \code{fields},
#'     using \code{&} logic across query element. By default, case sensitive.
#' @param field character() column names in resource to query, using
#'     \code{||} logic across multiple field elements. By default,
#'     matches pattern agains rname, rpath, and fpath. If exact
#'     matching, may only be a single value.
#' @return For 'bfcquery': A \code{bfc_tbl} of current resources in
#'     the database whose \code{field} contained query. If multiple
#'     values are given, the resource must contain all of the
#'     patterns. A tbl with zero rows is returned when no resources
#'     match the query.
#' @examples
#' bfcquery(bfc0, "Test")
#' bfcquery(bfc0, "^Test1$", field="rname")
#' @aliases bfcquery
#' @exportMethod bfcquery
setMethod("bfcquery", "BiocFileCacheBase",
    function(x, query, field=c("rname", "rpath", "fpath"), ...)
{
    stopifnot(is.character(query))
    stopifnot(all(field %in% .get_all_colnames(x)))

    name <- basename(tempfile(""))
    tbl <- .sql_get_resource_table(x)
    keep <- TRUE
    for (q in query)
        keep <- keep & Reduce(`|`, lapply(tbl[field], grepl, pattern = q, ...))
    rids <- intersect(tbl$rid[keep], bfcrid(x))
    bfcinfo(x, rids)
})

#' @export
setGeneric("bfccount",
    function(x) standardGeneric("bfccount")
)

#' @rdname BiocFileCache-class
#' @aliases bfccount,missing-method
#' @exportMethod bfccount
setMethod("bfccount", "missing",
    function(x)
{
    bfccount(x=BiocFileCache())
})

#' @describeIn BiocFileCache Get the number of objects in the file
#'     cache or query.
#' @return For 'bfccount': integer(1) Number of objects in the cache
#'     or query.
#' @examples
#' bfccount(bfc0)
#' bfccount(bfcquery(bfc0, "test"))
#' @aliases bfccount
#' @exportMethod bfccount
setMethod("bfccount", "BiocFileCacheBase",
    function(x)
{
    bfccount(bfcinfo(x))
})

#' @rdname BiocFileCache-class
#' @aliases bfccount,tbl_bfc-method
#' @exportMethod bfccount
setMethod("bfccount", "tbl_bfc",
    function(x)
{
    .sql_get_nrows(x)
})

#' @export
setGeneric("bfcneedsupdate",
    function(x, rids) standardGeneric("bfcneedsupdate"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcneedsupdate,missing-method
#' @exportMethod bfcneedsupdate
setMethod("bfcneedsupdate", "missing",
    function(x, rids)
{
    bfcneedsupdate(x=BiocFileCache(), rids=rids)
})

#' @describeIn BiocFileCache check if a resource needs to be updated
#' @return For 'bfcneedsupdate': named logical vector if resource
#'     needs to be updated. The name is the resource
#'     'rid'. \code{TRUE}: fpath \code{etag} or \code{modified} time of
#'     web resource more recent than in BiocFileCache; \code{FALSE}: fpath
#'     \code{etag} or \code{modified} time of web resource not more recent
#'     than in BiocFileCache; \code{NA}: web resource etag and modified time
#'     could not be determined. If the etag is available the function will use
#'     that information definitively and only compare last modified time if
#'     etag is not available.
#' @examples
#' bfcneedsupdate(bfc0, "BFC5")
#' @aliases bfcneedsupdate
#' @exportMethod bfcneedsupdate
setMethod("bfcneedsupdate", "BiocFileCacheBase",
    function(x, rids)
{
    if (missing(rids))
        rids <- .get_all_web_rids(x)
    stopifnot(all(rids %in% bfcrid(x)))
    if (!all(rids %in% .get_all_web_rids(x)))
        stop("rids not all web resources")

    helper <- function(x, rid) {
        .sql_update_time(x, rid)
        file_time <- .sql_get_last_modified(x, rid)
        fpath <- .sql_get_fpath(x, rid)
        file_etag <-  .sql_get_etag(x, rid)
        cache_info <- .httr_get_cache_info(fpath)
        web_time <- cache_info[["modified"]]
        web_etag <- cache_info[["etag"]]

        checkTime <- FALSE
        if (is.na(web_etag) || is.na(file_etag)) {
            checkTime <- TRUE
        } else {
            res <- !identical(file_etag, web_etag)
        }

        if (checkTime){
            if (is.na(file_time) || is.na(web_time)) {
                res <- NA
            } else {
                res <- as.Date(web_time, optional=TRUE) >
                    as.Date(file_time, optional=TRUE)
            }
        }
        res
    } # end helper

    result <- vapply(rids, helper, logical(1), x=x)
    # if web resources hasn't been locally downloaded yet
    result[rids %in% .get_rid_filenotfound(x)] = TRUE
    setNames(result, rids)
})

#' @export
setGeneric("bfcdownload",
    function(x, rid, proxy="", config=list(), ask=TRUE)
    standardGeneric("bfcdownload"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcdownload,missing-method
#' @exportMethod bfcdownload
setMethod("bfcdownload", "missing",
    function(x, rid, proxy="", config=list(), ask=TRUE)
{
    bfcdownload(x=BiocFileCache(), rid=rid, proxy=proxy, config=config, ask=ask)
})

#' @describeIn BiocFileCache Redownload resource to location in cache
#' @return For 'bfcdownload': character(1) path to downloaded resource
#'     in cache.
#' @examples
#' bfcdownload(bfc0, "BFC5")
#' @aliases bfcdownload
#' @exportMethod bfcdownload
setMethod("bfcdownload", "BiocFileCache",
    function(x, rid, proxy="", config=list(), ask=TRUE)
{
    stopifnot(!missing(rid), length(rid) == 1L)
    stopifnot(.sql_get_rtype(x, rid) == "web")
    stopifnot(rid %in% bfcrid(x))

    .sql_update_time(x, rid)

    if (ask && file.exists(.sql_get_rpath(x, rid))){
        doit <-
            .util_ask("Redownloading. This will overwrite exisiting file.\n",
                      "Continue?")
    } else{
        doit <- TRUE
    }
    if (doit)
        .util_download_and_rename(x, rid, proxy, config, "bfcdownload()")

    setNames(bfcrpath(x, rids=rid), rid)
})


#' @export
setGeneric("bfcremove",
    function(x, rids) standardGeneric("bfcremove"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcremove,missing-method
#' @exportMethod bfcremove
setMethod("bfcremove", "missing",
    function(x, rids)
{
    bfcremove(x=BiocFileCache(), rids=rids)
})

#' @describeIn BiocFileCache Remove a resource to the database.  If
#'     the local file is located in \code{bfccache(x)}, the file will
#'     also be deleted. This will not delete information in any metadata
#'     table.
#' @return For 'bfcremove': updated BiocFileCache object, invisibly
#' @examples
#' bfcremove(bfc0, rid3)
#' bfcinfo(bfc0)
#' @aliases bfcremove
#' @exportMethod bfcremove
setMethod("bfcremove", "BiocFileCache",
    function(x, rids)
{
    stopifnot(all(rids %in% bfcrid(x)))

    rpaths <- vapply(rids, .sql_get_rpath, character(1), bfc=x)
    cached <- startsWith(rpaths, bfccache(x))

    .sql_remove_resource(x, rids)
    status <- .util_unlink(rpaths[cached])

    invisible(x)
})

#' @export
setGeneric("bfcsync",
    function(x, verbose = TRUE, ask = TRUE) standardGeneric("bfcsync"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases bfcsync,missing-method
#' @exportMethod bfcsync
setMethod("bfcsync", "missing",
    function(x, verbose = TRUE, ask = TRUE)
{
    bfcsync(x=BiocFileCache(), verbose=verbose, ask=ask)
})

#' @describeIn BiocFileCache sync cache and resource.
#' @param verbose logical(1) If descriptive message and list of issues
#'     should be included as output.
#' @return For 'bfcsync': logical(1) indicating whether the cache is
#'     in sync (\code{TRUE}) or not. 'verbose' is TRUE by default, so
#'     descriptive messages will also be included.
#' @examples
#' bfcsync(bfc0)
#' bfcremove(bfc0, "BFC1")
#' bfcsync(bfc0, FALSE)
#' @aliases bfcsync
#' @importFrom utils capture.output
#' @exportMethod bfcsync
setMethod("bfcsync", "BiocFileCache",
    function(x, verbose=TRUE, ask = TRUE)
{
    stopifnot(is.logical(verbose), length(verbose) == 1L, !is.na(verbose))

    # files not found
    rids <- .get_rid_filenotfound(x)

    # files untracked in cache location
    files <- file.path(bfccache(x), setdiff(dir(bfccache(x)),.CACHE_FILE))
    paths <- .get_all_rpath(x)
    # normalizePath on windows
    # can't across platform - no opt on linux but added hidden on mac
    if (tolower(.Platform$OS.type) == "windows"){
        files = normalizePath(files)
        paths = normalizePath(paths)
    }
    untracked <- setdiff(files, paths)

    rids0 <- rids; untracked0 <- untracked

    if (verbose && (length(rids) != 0L))
        message(
            "entries without corresponding files: ",
            paste0("'", rids, "'", collapse=" ")
        )
    if (ask && (length(rids) != 0L)) {
        doit <- .util_ask(paste("delete", length(rids), "entries?"))
        rids <- rids[doit]
    }

    if (verbose && (length(untracked) != 0L))
        message(
            "files without cache entries\n  ",
            paste(untracked, collpase="\n  ")
        )
    if (ask && (length(untracked) != 0L)) {
        doit <- .util_ask(paste("delete", length(untracked), "files?"))
        untracked <- untracked[doit]
    }

    .sql_remove_resource(x, rids)
    .util_unlink(untracked)

    !length(setdiff(rids0, rids)) && !length(setdiff(untracked0, untracked))
})


#' @export
setGeneric("exportbfc",
    function(x, rids,
             outputFile="BiocFileCacheExport.tar", outputMethod=c("tar","zip"),
             verbose=TRUE, ...)
    standardGeneric("exportbfc"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases exportbfc,missing-method
#' @exportMethod exportbfc
setMethod("exportbfc", "missing",
    function(x, rids,
             outputFile="BiocFileCacheExport.tar", outputMethod=c("tar","zip"),
             verbose=TRUE, ...)
{
    exportbfc(x=BiocFileCache(), rids=rids,
              outputFile=outputFile, outputMethod=outputMethod,
              verbose=verbose, ...)
})

#' @describeIn BiocFileCache Create exportable file containing BiocFileCache.
#' @param outputFile character(1) The <filepath>/basename for the output
#' archive. Please include appropriate extension based on outMethod and any
#' additional parameters selected for \code{utils::tar} or \code{utils::zip}
#' @param outputMethod Either 'tar' or 'zip' for how the directory should
#' be archived. Default is 'tar'.
#' @return character(1) The outputFile path.
#' @examples
#' \dontrun{exportbfc(bfc)}
#' @aliases exportbfc
#' @exportMethod exportbfc
setMethod("exportbfc", "BiocFileCacheBase",
    function(x, rids,
             outputFile="BiocFileCacheExport.tar", outputMethod=c("tar","zip"),
             verbose=TRUE, ...)
{
    if (missing(rids))
        rids <- bfcrid(x)

    stopifnot(all(rids %in% bfcrid(x)))
    stopifnot(length(outputFile) == 1L, is.character(outputFile))
    outputMethod <- match.arg(outputMethod)
    stopifnot(is.logical(verbose), length(verbose) == 1L)

    bfc <- x[rids]
    if (length(bfc) == 0L)
        stop("No valid rids selected")

    dir <- file.path(tempdir(), "BiocFileCacheExport")
    dir.create(dir)
    ids <-  bfcrid(bfc)

    file.copy(.sql_dbfile(x), dir)
    newbfc <- BiocFileCache(dir)
    idrm <- setdiff(.get_all_rids(newbfc), ids)
    if (length(idrm) != 0)
        newbfc <- bfcremove(newbfc, rids=idrm)

    res <- vapply(ids, .util_export_file, character(1),
                  bfc=x, dir=dir)

    # 'relative' = ok, 'web'= not download
    # 'local' = file not in cache, 'NA' = file not found
    if (any(res == "web", na.rm=TRUE)){
        webid <- names(which(res == "web"))
        if (verbose)
            message(paste0("The following are identified as web resources\n",
                           "but have not been downloaded yet. No associated\n",
                           "files will be exported:\n",
                           "  ", paste0("'", webid, "'", collapse=" "), "\n\n"))
    }
    if (any(res == "local", na.rm=TRUE)){
        locid <- names(which(res == "local"))
        if (verbose)
            message(paste0("The following are identified as local resources.\n",
                           "A copy of the file will be exported:\n",
                           "  ", paste0("'", locid, "'", collapse=" "), "\n\n"))
        for(i in locid){
            orig <- .sql_get_rpath(x, rid=i)
            newpath <- file.path(dir, basename(orig))
            if (file.exists(newpath)){
                filename <- paste(basename(tempfile("", bfccache(newbfc))),
                              basename(orig), sep="_")
                newpath <- file.path(dir, filename)
            }
            file.copy(orig, newpath)
        }
    }
    if (any(is.na(res))){
        naid <- names(which(is.na(res)))
        if (verbose)
            message(paste0("The following had a file that was not found.\n",
                       "The file is not included and the rid will be removed\n",
                       "from the BiocFileCache object being exported:\n",
                       "  ", paste0("'", naid, "'", collapse=" "), "\n\n"))
       newbfc <- bfcremove(newbfc, rids=naid)
    }

    if (length(bfcmetalist(newbfc)) != 0){
        metaList <- bfcmetalist(newbfc)
        res <- vapply(metaList, .sql_filter_metadata, logical(1),
               bfc=newbfc, verbose=verbose)
    }

    # tar/zip up directory
    origdir <- getwd()
    if (dirname(outputFile) == ".")
        outputFile = file.path(origdir, outputFile)
    setwd(dirname(dir))
    files = basename(dir)

    archive <- function(outputFile, how = c("tar", "zip"), files, ...) {
        fun <- switch(how, tar = tar, zip = zip)
        fun(outputFile, files, ...)
    }

    archive(outputFile=outputFile, how=outputMethod, files=files, ...)
    setwd(origdir)
    .util_unlink(dir, recursive=TRUE)
    outputFile
})

#' @export
setGeneric("importbfc",
    function(filename, archiveMethod=c("untar","unzip"),
             exdir=".", ...)
    standardGeneric("importbfc"),
    signature = "filename"
)

#' @describeIn BiocFileCache Import file created with exportbfc containing
#' BiocFileCache.
#' @param filename character(1) The name of the archive.
#' @param archiveMethod Either 'untar' or 'unzip' for how the directory should
#' be extracted. Default is 'untar'.
#' @param exdir Directory to extract files too. See \code{utils::untar} or
#' \code{utils::unzip} for more details.
#' @return A BiocFileCache object
#' @examples
#' \dontrun{importbfc("ExportBiocFileCache.tar")}
#' @aliases importbfc
#' @exportMethod importbfc
setMethod("importbfc", "character",
    function(filename, archiveMethod=c("untar","unzip"),
             exdir=".", ...)
{
    exportPath <- file.path(exdir, "BiocFileCacheExport")
    stopifnot(!dir.exists(exportPath))
    stopifnot(length(exdir) == 1L, is.character(exdir))
    stopifnot(length(filename) == 1L, is.character(filename))
    archiveMethod = match.arg(archiveMethod)

    inflate <- function(filename, how = c("untar", "unzip"), exdir, ...) {
        fun <- switch(how, untar = untar, unzip = unzip)
        fun(filename, exdir=exdir, ...)
    }
    inflate(filename=filename, how=archiveMethod, exdir=exdir, ...)
    bfc = BiocFileCache(exportPath)
    bfc
})


#' @export
setGeneric("makeBiocFileCacheFromDataFrame",
    function(df, cache,
             actionLocal=c("move","copy","asis"), actionWeb=c("move","copy"),
             metadataName,
             ...)
    standardGeneric("makeBiocFileCacheFromDataFrame"),
    signature = "df"
)

#' @describeIn BiocFileCache Convert a dataframe or tibble to BiocFileCache. If
#' there are a lot of resources being added this could take some time but if a
#' cache is saved in a permanent location this should only have to be run
#' once. The original data.frame must have the required columns 'rtype',
#' 'fpath', and 'rpath'; See the vignette for more information on the expected
#' information contained in these columns. Similarly, the optional columns
#' 'rname', 'etag', and 'last_modified_time' may be included. Any additional
#' columns not listed as required or optional will be kept as an additional
#' metadata table in the BiocFileCache database.
#' @param df data.frame or tibble to convert
#' @param actionLocal If local copy of file should be moved, copied or left in
#' original location. See 'action' param of bfcadd.
#' @param actionWeb If a local copy of a remote resource already exists, should
#' the file be copied or moved to the cache. Locally downloaded remote resources
#' must exist in the cache location.
#' @param metadataName If there are additional columns of data in the original
#' data.frame besides required BiocFileCache columns, this data will be added as
#' a metadata table with this name.
#' @return A BiocFileCache object
#' @aliases makeBiocFileCacheFromDataFrame
#' @exportMethod makeBiocFileCacheFromDataFrame
setMethod("makeBiocFileCacheFromDataFrame", "ANY",
    function(df, cache,
             actionLocal=c("move","copy","asis"), actionWeb=c("move","copy"),
             metadataName,
             ...)
{
    stopifnot(is.data.frame(df))
    DF <- as.data.frame(df, stringsAsFactors = FALSE)
    if (missing(cache)) cache <- user_cache_dir(appname="BiocFileCache")
    stopifnot(is.character(cache), length(cache) == 1L, !is.na(cache),
              !dir.exists(cache))
    actionLocal <- match.arg(actionLocal)
    actionWeb <- match.arg(actionWeb)

    .required <- c("rtype", "fpath", "rpath")
    .optional <- c("rname", "etag", "last_modified_time")
    .possible <- c(.required, .optional)
    if (!all(.required %in% names(DF))){
        stop("One of the following required columns in not in data.frame:",
             "\n   ", paste(.required, collapse=", "),
             "\n   Please insert into original data.frame")
    }
    .optional <- .optional[.optional %in% names(DF)]
    .available <- c(.required, .optional)
    metadata <- names(DF)[!names(DF) %in% .available]
    if (any(metadata %in% c("rid",.RESERVED$COLUMNS))){
        nocols <- c("rid", setdiff(.RESERVED$COLUMNS, .possible))
        stop("The following are reserved column names:",
             "\n    ", paste(nocols, collapse=", "),
             "\n    Please rename offending column name.")
    }
    if (length(metadata) != 0)
        stopifnot(!missing(metadataName),
                  is.character(metadataName), length(metadataName) == 1L,
                  !is.na(metadataName), !(metadataName %in% .RESERVED$TABLES))

    # validity of .required columns
    stopifnot(is.character(DF[["rtype"]]),
              is.character(DF[["fpath"]]),
              is.character(DF[["rpath"]]))
    rtype <- DF[["rtype"]]
    fpath <- DF[["fpath"]]
    rpath <- DF[["rpath"]]

    stopifnot(all(rtype %in% c("web", "local")))
    web <- which(rtype == "web")
    if (length(web) != 0L){
        webpaths <- fpath[web]
        if(!all(
            vapply(webpaths, FUN = function(x){
                startsWith(x, "http") || startsWith(x, "ftp")},
                   logical(1))))
            stop("Some source urls for files identified with 'rtype=web'\n",
                 "  do not start with: http, https, or ftp")
    }
    nonweb <- which(rtype != "web")
    if (length(nonweb) != 0L){
        if (!all(file.exists(rpath[nonweb])))
            stop("Not all files identified as 'rtype=local' have existing files")
    }

    # validity of .optional columns
    if (length(.optional) != 0L){
        check <- vapply(.optional, FUN = function(x, df){
            is.character(df[[x]])}, logical(1), df=DF)
        if (!all(check)){
            stop("The following columns must have entries of type 'character':",
                 "\n    ", paste(.optional, collapse=", "))
        }
    }
    if ("last_modified_time" %in% .optional){
        check <- tryCatch({
            as.Date(DF[["last_modified_time"]])
            TRUE
        }, error=function(e) {
            warning(conditionMessage(e))
            FALSE
        })
        if (!check){
            stop("Column 'last_modified_time' must have entries of type ",
                 "'character' that can be converted to Date via 'as.Date()'")
        }
        modified <- DF[["last_modified_time"]]
    } else {
        modified <- rep(NA_character_, nrow(DF))
    }

    if ("rname" %in% .optional){
        rname <- DF[["rname"]]
    } else {
        rname <- fpath
    }

    if ("etag" %in% .optional){
        etag <- DF[["etag"]]
    } else {
        etag <- rep(NA_character_, nrow(DF))
    }

    bfc <- BiocFileCache(cache)

    # add resources to cache
    for(i in seq_len(nrow(DF))){

        if (rtype[i] == "web"){
            npath <- fpath[i]
            action <- actionWeb
        }else{
            npath <- rpath[i]
            action <- actionLocal
        }

        res <- bfcadd(bfc, rname=rname[i], fpath = npath, rtype = "auto",
                      action = action, download=FALSE, ...)
        rid <- names(res)
        .sql_set_last_modified(bfc, rid, modified[i])
        .sql_set_etag(bfc, rid, etag[i])
    }

    # if local version of remote exists, copy or move
    for(i in web){
        cpath <- bfcrpath(bfc, rids=paste0("BFC",i))
        opath <- rpath[i]
        if (file.exists(opath)){
            switch(actionWeb,
                   copy = file.copy(opath, cpath, ...),
                   move = file.rename(opath, cpath)
                   )
        }
    }

    # create metadata
    if (length(metadata) != 0){
        tbl <- cbind(rid=paste0("BFC",seq_len(nrow(DF))),
                     DF[,metadata,drop=FALSE])
        bfcmeta(bfc, name=metadataName) <- tbl
    }

    bfc
})


#' @export
setGeneric("cleanbfc",
    function(x, days = 120, ask = TRUE) standardGeneric("cleanbfc"),
    signature = "x"
)

#' @rdname BiocFileCache-class
#' @aliases cleanbfc,missing-method
#' @exportMethod cleanbfc
setMethod("cleanbfc", "missing",
    function(x, days = 120, ask = TRUE)
{
    cleanbfc(x=BiocFileCache(), days=days, ask=ask)
})

#' @describeIn BiocFileCache Remove old/unused files in
#'     BiocFileCache. If file to be removed is not in the bfccache
#'     location it will not be deleted.
#' @param days integer(1) Number of days between accessDate and
#'     currentDate; if exceeded entry will be deleted.
#' @param ask logical(1) Prompt if really want to remove cache and
#'     files.
#' @return For 'cleanbfc': updated BiocFileCache, invisibly.
#' @examples
#' \dontrun{cleanbfc(bfc, ask=FALSE)}
#' @aliases cleanbfc
#' @exportMethod cleanbfc
setMethod("cleanbfc", "BiocFileCache",
    function(x, days = 120, ask=TRUE)
{
    stopifnot(is.numeric(days), length(days) == 1L, !is.na(days))
    stopifnot(is.logical(ask), length(ask) == 1L, !is.na(ask))

    rids <- .sql_clean_cache(x, days)
    rpaths <- vapply(rids, .sql_get_rpath, character(1), bfc=x)
    cached <- startsWith(rpaths, bfccache(x))

    if (ask) {
        txt0 <- paste0(" file ", sQuote(rpaths))
        txt <- sprintf(
            "Remove id %d %d", sQuote(rids), ifelse(cached, txt0, "")
        )
        doit <- vapply(txt, .util_ask, logical(1))

        rids <- rids[doit]
        cached <- cached & doit
    }

    .sql_remove_resource(x, rids)
    .util_unlink(rpaths[cached])

    invisible(x)
})

#' @export
setGeneric("removebfc",
    function(x, ask = TRUE) standardGeneric("removebfc"),
    signature="x"
)

#' @rdname BiocFileCache-class
#' @aliases removebfc,missing-method
#' @exportMethod removebfc
setMethod("removebfc", "missing",
    function(x, ask = TRUE)
{
    removebfc(x=BiocFileCache(), ask=ask)
})

#' @describeIn BiocFileCache Completely remove the BiocFileCache
#' @return For 'removebfc': TRUE if successfully removed.
#' @examples
#' \dontrun{removebfc(bfc, ask=FALSE)}
#' @aliases removebfc
#' @exportMethod removebfc
setMethod("removebfc", "BiocFileCache",
    function(x, ask=TRUE)
{
    stopifnot(is.logical(ask), length(ask) == 1L, !is.na(ask))

    txt <- paste("remove cache and", length(x), "resource(s)?")
    if (!ask || .util_ask(txt))
        doit <- .util_unlink(bfccache(x), recursive=TRUE)

    doit
})

#' @describeIn BiocFileCache Display a \code{BiocFileCache} instance.
#' @param object A \code{BiocFileCache} instance.
#' @exportMethod show
setMethod("show", "BiocFileCacheBase",
    function(object)
{
    cat("class: ", class(object), "\n",
        "bfccache: ", bfccache(object), "\n",
        "bfccount: ", bfccount(object), "\n",
        "For more information see: bfcinfo() or bfcquery()\n",
        sep="")
})
